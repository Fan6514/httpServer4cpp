# 互斥锁

互斥锁是使用最多的同步原语，用来排他性地访问共享数据，任何时刻最多只能有一个线程在 mutex 划出的临界区活动。

- 使用 RAII 封装 mutex 创建、销毁、加锁和解锁操作
- 使用非递归 mutex（不能重复加锁）
- 不手动调用 lock() 和 unlock() 函数，由 Guard 对象的构造和析构函数负责

# 条件变量

条件变量是等待原语，等待一个或多个线程等待某个布尔表达式为真。

对于wait端：
- 必须与mutex一起使用，对表达式地读写要受mutex保护
- mutex上锁后才能调用wait()
- 判断表达式和wait()放在while循环中

> 使用if语句包装wait方法会出现**虚假唤醒**
> 
> **虚假唤醒**：当一定的条件触发时会唤醒很多在阻塞态的线程，但只有部分的线程唤醒是有用的，其余线程的唤醒是多余的。

对于signal/broadcast端：
- 不一定要在mutex上锁后调用signal
- 在signal之前一般要修改表达式
- 修改表达式通常要mutex保护
- broadcast通常用于表示状态变化，signal通常用于表示资源可用

总结：
- 线程同步尽量使用高层同步措施，线程池、队列、倒计时等
- 使用互斥器和条件变量完成剩余同步任务，采用RAII和Scoped Locking

